# ch4. 성능

## 4-1. 브라우저는 어떻게 작동하는가?

### 렌더링

- 브라우저는 HTML 문서를 받아 파싱하여 DOM 트리 생성
  - 이 때, CSS를 처리해 CSSOM도 만듬
- 이 DOM 트리 및 CSSOM을 바탕으로 페이지에 콘텐츠를 렌더링

렌더링 주요 단계

- 레이아웃: CSS 및 레이아웃 규칙을 기반으로 페이지에서 각 요소의 크기와 위치를 계산
- 페인트: 각 요소를 화면에 그림

### 로딩

브라우저는 HTML 문서를 받으면 문서에 참조된 리소스(이미지, 스타일 시트, 스크립트 등)를 로딩

- 로딩할 리소스가 많으면 병목이 될 수 있음
- Lazy Loading 또는 Prefetching, Preloading 을 통해 미래에 사용할 리소스를 미리 준비할 수 있다

## 4-2. 자바스크립트에서의 비용 이해하기와 줄이기

- 느린 CPU의 데스크탑 혹은 모바일 기기에서는 웹 애플리케이션의 자바스크립트 연산이 많으면 안좋은 사용자 경험을 만들 수 있다

### 다운로드 시간(네트워크 전송)

자바스크립트와 관련된 가장 큰 어려움은 다운로드 시간을 줄이는 것이다

- 많은 사용자들이 아직 느린 네트워크 연결 속도(특히 이동중일 때)를 경험하고 있다

다운로드 시간을 최적화 방법1) JS 번들의 크기를 작게 유지해야 한다

- 특히 모바일 기기에서 중요
- 번들 크기가 작을 수록 다운로드 속도가 개선될 뿐만 아니라,
  - 메모리를 적게 사용하며
  - CPU 사용 비용도 낮아진다

다운로드 시간 최적화 방법2) 하나의 거대한 번들 사용 피하기

- 번들 크기가 50~100 KB를 초과한다면 작은 번들로 나눠야 한다

### 실행시간

다운로드 완료 후에는 스크립트 실행 시간이 대다수의 비용을 차지

- 브라우저 메인 스레드가 자바스크립트를 실행하느라 바쁘면 사용자 상호작용이 지연될 수 있다
- 스크립트 실행 시간과 네트워크 관련 병목을 최적화해야 함

스크립트 실행 시간 최적화

- 메인 스레드를 계속 점유하는 긴 태스크가 있다면 쪼개기
- 거대한 인라인 스크립트 피하기
  - 인라인 스크립트는 메인 스레드에서 파싱 및 컴파일된다
  - 스크립트 크기가 1KB가 넘으면 인라인으로 작성하면 안됨
  - 1KB 이상의 외부 스크립트들에 (바이트)코드 캐싱 적용됨

### 파싱과 컴파일

2024년, 최신 크롬 버전 기준 브라우저의 파싱 및 컴파일 속도가 매우 향상되었다

- V8은 이제 메인 스레드를 블로킹하지 않고 자바스크립트를 파싱 및 컴파일할 수 있다
- 과거의 크롬은 스크립트 전체를 다운로드한 뒤 파싱을 시작했다

V8엔진의 bytecode caching

- 스크립트 1번째 요청 시: 브라우저가 해당 스크립트 다운로드 후 V8엔진이 컴파일
  - 해당 파일은 브라우저의 온디스크 캐시에 저장됨
- 스크립트 2번째 요청 시: 요청받은 파일의 재다운로드없이, 캐시에서 꺼내 재컴파일
  - 컴파일된 코드를 직렬화하여 캐싱된 스크립트 파일에 메타데이터로 추가
- 스크립트 3번째 요청 시(코드 캐싱): 메타데이터에 저장된 바이트코드를 꺼내 V8에서 역직렬화 및 컴파일 건너뜀
- 이 때, 첫 2번의 방문이 72시간 이내에 발생하면 코드 캐싱 실행

## 4-3. 상호작용 최적화

interaction-readiness

- 사용자의 상호작용(클릭, 스크롤, 타이핑 등)에 웹페이지가 얼마나 빠르게 반응하는지 평가하는 웹 성능 지표
- 네트워크 지연, 서버 처리 시간, 브라우저 렌더링 성능 등에 영향을 받음

측정 지표

- TTI(time to interactive): 상호작용 시작에 걸리는 시간
- TBT(total blocking time): 총 차단 시간
- INP(interaction to next paint): 상호 작용 시작부터 다음 페인트 완료까지 걸리는 시간
  - 웹페이지 로딩 및 런타임 응답과 관련

React 타임 슬라이싱

- startTransition 및 Suspense 로 구현
- INP를 개선하여 자동 완성같은 큰 트랜지션이 발생하는 동안에도 상호작용에 잘 반응하게 함
- Next.js App Router 에서 라우트 전환 시 startTransition 기본 활용하여 반응성 개선

## 4-4. 네트워킹

HTTP/3

- HTTP의 최신 버전으로 인터넷 성능 및 보안을 개선
- QUIC 전송 프로토콜 사용: 지연과 혼잡을 줄임
- 주요 브라우저에서 모두 지원

스트리밍

- 전체 파일 혹은 리소스가 로딩될 때까지 기다리지 않고 데이터를 덩어리 또는 조각으로 주고받음
- 사용자들이 콘텐츠를 빠르게 이용할 수 있음

플러싱

- 전체 응답이 생성되기 전에 데이터를 브라우저에게 보냄
- 특히 콘텐츠 스트리밍 시 유용
- 모든 리소스가 로딩되기 전에 페이지 렌더링을 시작하여 성능 개선

## 4-5. 서드파티 의존성 줄이기

- 서드파티 의존성을 줄이기 위해 시도할 만한 방법들

가장 비싼(느린) 의존성 식별하기

- Chrome Devtools, Lighthouse, WebPageTest 같은 도구를 활용해서 가장 느리게 로딩되는 의존성을 식별
- import cost 같은 도구도 활용 가능할 듯

각 의존성의 필요성 평가

- 가장 느린 의존성을 식별하고 대체할 수 있는지 평가

의존성 로등을 최적화

- Lazy Loading, Code Splitting, Tree Shaking 같은 기법으로 서드파티 의존성 최적화 가능
- Tree Shaking
  - 번들러(Vite, Webpack) 도구들이 주로 사용하는 기법
  - 사용하지 않는 코드나 불필요한 export 등을 제거

CDN 호스팅 사용

- 다른 대륙의 해외 사용자가 가까운 서버에서 의존성들을 다운로드하게 할 수 있음

번들 분석

- Webpack Bundle Analyzer, Lighthouse Treemap 같은 도구를 사용하면 가장 많은 공간을 차지하는 의존성을 식별할 수 있음

개별 서드파티 의존성의 configure 최적화

- 성능 최적화 및 최소 기능만 사용하게하기
  - 예) 데이터 시각화 라이브러리의 경우, 표시하는 항목 줄이기

## 4-6. 렌더링 패턴

웹 페이지 특성에 맞는 렌더링 패턴을 도입하여 성능 최적화

- CSR, SPA: 브라우저에서 완전히 실행되는 애플리케이션
- MPA(Multi-page application): 최소한의 CSR + 서버에서 완전히 실행되는 애플리케이션
- SSG를 위한 정적 렌더링: 사전 렌더링된 정적 컨텐츠 + 필요시 CSR
- SSR: HTML 컨텐츠를 서버에서 동적으로 렌더링
- partial hydration: 클라이언트에서 컴포넌트 일부만 hydration
  - 예) React Server Component
- progressive hydration: 점진적 hydration. 클라이언트에서 컴포넌트별 hydration 순서 통제
- 아일랜드 아키텍쳐(Islands architecture): 정적 사이트에 여러 엔트리 포인트가 존재하여 동적 렌더링
  - 예) Astro
- incremental static generation: 점진적 정적 생성. 초기 구축 이후에도 정적 사이트를 동적으로 증강하거나 수정
  - 예) Next.js ISR, Gatsby DSG
- streaming SSR: 서버측에서 렌더링된 컨텐츠를 작은 스트림 덩어리로 나누는 것
- resumability: 서버에서 프레임워크 상태를 직렬화해 클라이언트가 중복된 코드 없이 실행 재개 가능
- ESR(edge side rendering): 렌더링된 HTML을 엣지(서버리스)에서 대체한 뒤 이를 클라이언트로 보냄

## 4-7. 인지적 성능 최적화

- Skeleton UI 또는 Placeholder UI 사용
