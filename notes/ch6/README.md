# ch6. 데이터 가져오기(Data Fetching)

## 6-1. 브라우저 API와 간단한 HTTP 클라이언트

HTTP 통신을 위한 기본적인 방법

- Fetch API: 자바스크립트 내장 API
- Axios: 에러 핸들링, 인터셉터, XSRF 공격 보호 등 기능이 몇가지 추가된 HTTP 라이브러리

2가지 방법 모두 저수준이라 애플리케이션 규모가 커지면, 반복이 발생할 수 밖에 없다

## 6-2. 보다 세련된 데이터 페칭 라이브러리

리액트 쿼리, SWR 같은 라이브러리를 사용하면 데이터 페칭, 캐싱, 동기화 등의 편리한 기능을 사용할 수 있다

### 캐싱

리액트 쿼리는 캐시 데이터를 메모리에 보관한다

- 데이터를 페칭하면 기본적으로 캐시에 자동 저장하고
- 컴포넌트가 데이터를 필요로 하면 우선 데이터를 캐시에서 빠르게 가져온다
- 그리고 백그라운드에서는 서버로 새로운 요청을 보낸다
- 만약 서버의 데이터가 변경되었다면 캐시를 업데이트하고 컴포넌트를 리렌더링하여 최신 데이터를 보여준다

### stale time

- 데이터가 최신(fresh)이라고 간주할 수 있는 시간(ms)
- 기본값: 0

예시) staleTime 를 1000 \* 60 (1분) 으로 설정하면?

- 1번째 쿼리 후, 1분 지나기 전에 2번째 쿼리가 만들어지면, 아직 data가 fresh하다고 간주하여 새로운 백그라운드 요청을 만들지 않는다
- 대신 캐시에서 데이터를 꺼내 제공

## 6-3. 캐시 업데이트하기

리액트 쿼리는 캐시와 직접 상호작용하고 캐시를 업데이트할 수 있는 일련의 유틸리티들을 제공한다

- 예를 들어 useMutation 훅을 통해 서버의 데이터 변경에 성공했다면, 캐시 업데이트도 필요할 것이다
- setQueryData() 함수를 사용하면 쿼리 키를 기반으로 특정 쿼리의 캐시를 업데이트할 수 있다
  - 이 메서드를 사용하면 낙관적 업데이트(optimistic update)를 구현할 수 있다
- 낙관적 업데이트: mutation 이후 서버 응답을 기다리지 않고 즉시 UI를 변경하여 사용자 편의성 향상
  - 예) 좋아요 버튼 클릭 시 바로 좋아요 버튼을 파란색으로 변경
  - mutation이후(onMutate) 현재 쿼리 키의 모든 요청 취소(cancelQueries)
  - 현재 캐시를 백업(onMutate에서 반환해줌)
  - setQueryData로 캐시를 직접 업데이트 (UI 즉시 반영됨)
  - mutation이 실패하면(onError) setQueryData 함수로 백업된 값으로 캐시 변경 (UI 즉시 반영됨)
  - 모든 요청이 끝나면(onSettled) 캐시 무효화

### 데이터 미리 가져오기(Prefetching)

- 데이터를 미리 가져오면 사용자의 인지된 로딩 시간을 줄여서 매끄러운 사용자 경험을 제공할 수 있다
- 리액트 쿼리의 prefetchQuery() 함수를 사용한다
- 미리 가져온 데이터는 캐시에 저장되고, 같은 쿼리 키로 useQuery를 호출하면 데이터 페칭 없이 캐시에 바로 접근할 수 있다

### 플레이스홀더 데이터

플레이스홀더 데이터는 다음과 같은 시나리오에서 유용하다

- 느린 네트워크 요청을 다룰 때: 쿼리를 완료하는데 상당한 시간이 소요된다면 빈 페이지나 Loader보다 placeholder 또는 skeleton을 사용하는 편이 사용자의 참여를 유지할 수 있다
- 낙관적 업데이트를 사용할 때
- 일관성있는 레이아웃을 보장할 때: 데이터 페칭 전후로 레이아웃이 달라지면 사용자 경험이 안좋아질 수 있다
- 리액트 쿼리의 placeholderData 옵션을 사용하면 특정 쿼리에 대한 placeholder data를 표시할 수 있다
- initialData 옵션을 사용하면 placeholder 데이터를 표시하면서 동시에 캐시에도 저장할 수 있다

### 재시도 메커니즘

리액트 쿼리의 retry 옵션을 사용하면 쿼리 요청 재시도 횟수를 원하는 값으로 설정할 수 있다

- 기본값: 3회
- true: 요청이 성공할 때까지 무한 재시도
- false: 재시도 X
