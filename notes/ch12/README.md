# ch.12 테스팅

- 테스팅: 애플리케이션이 기대한 대로 작동하고 모든 기능적/비기능적 요구사항을 만족함을 보장하는 것

## 12-1. 단위 테스트

단위 테스트(unit test)

- 애플리케이션의 (코드베이스와 격리된) 개별 컴포넌트 또는 기능 검증에 초점
- 각 컴포넌트 혹은 함수를 검증
- Jest, React Testing Library, Vitest 등을 대표적으로 사용
  - Jest: JavaScript 테스팅 프레임워크. mocking, code corverage, parallel test execution 등 유용한 여러 기능을 제공
  - React Testing Library: 리액트 컴포넌트 테스팅에 특화된 경량 라이브러리. 사용자 경험에 초점을 맞춘 테스트 작성 가능

### 단위 테스트 작성 예시: 간단한 카운터 페이지

필요한 라이브러리

- `jest` - JavaScript 테스팅 프레임워크 (테스트 러너)
- `@jest/globals` - Jest 전역 함수들 (`describe`, `test`, `expect` 등) 제공
- `@types/jest` - Jest의 TypeScript 타입 정의
- `jsdom` - Node.js에서 DOM API 제공 (브라우저 환경 모방)
- `jest-environment-jsdom` - Jest에서 jsdom 환경 사용 설정
- `@testing-library/react` - React 컴포넌트 렌더링 및 테스트 유틸리티
- `@testing-library/dom` - DOM 요소 쿼리 및 상호작용 유틸리티
- `@testing-library/jest-dom` - DOM 관련 Jest matcher 확장
- `@babel/core`, `@babel/preset-env`, `@babel/preset-react`, `@babel/preset-typescript`, `babel-jest` - JSX/TypeScript 코드를 Node.js에서 실행 가능하도록 변환
- `ts-node` - TypeScript 설정 파일 (`jest.config.ts`) 실행 지원

설정 파일

- `jest.config.ts` - Jest 테스트 환경 설정
- `.babelrc` - JSX/TypeScript 변환 설정
- `src/setupTests.ts` - 테스트 전역 설정 (Jest DOM matcher 등록)

테스트 진행 과정

1. **테스트 파일 생성** - `CounterPage.test.tsx` 파일 작성
2. **테스트 환경 설정**
   - `render()`: React 컴포넌트를 가상 DOM에 렌더링
   - `screen`: 렌더링된 요소들에 접근하기 위한 쿼리 제공
3. **요소 선택 및 검증**
   - `screen.getByText()`: 텍스트로 요소 찾기
   - `screen.getByRole()`: 역할(role)로 요소 찾기
   - `expect().toBeInTheDocument()`: 요소가 DOM에 존재하는지 검증
4. **사용자 상호작용 시뮬레이션**
   - `fireEvent.click()`: 클릭 이벤트 발생
   - 상태 변화 후 UI 업데이트 확인
5. **테스트 실행** - `pnpm test` 명령어로 모든 테스트 실행

테스트 작성

- src/pages/CounterPage.tsx 참고
- count 값은 span 엘리먼트 내부에 올바르게 표시되며 기본값은 0이다
- count 값은 + 버튼 클릭 시 1 증가한다
- count 값은 - 버튼 클릭 시 1 감소한다

### 정리, 동작, 확인 패턴 (AAA 패턴)

- 단위 테스트를 명확하고 간결한 형태로 구조화하기 위해 널리 받아들여지는 접근법
- 테스트를 정리(arrange), 동작(act), 확인(assert) 의 3단계로 나눈다

1. 정리(arrange)

- 테스트 대상 컴포넌트 혹은 시스템의 초기 단계 설정
- 특정 props를 사용해 컴포넌트를 렌더링하거나, mock 객체를 만들거나 필요한 의존성들을 초기화

2. 동작(act)

- 동작을 수행하거나 사용자 인터랙션 또는 시스템 운영을 시뮬레이션하는 이벤트를 트리거
- 클릭이나 키 입력, 함수 호출, 컴포넌트 상태 업데이트 같은 이벤트 트리거 동작

3. 확인(assert)

- 이전 단계의 동작이 기대한대로 작동했는지 확인
  - assertion을 사용해서 특정 조건이 True인지 확인
- 어떤 요소가 DOM 안에 존재하는지 확인하거나, 업데이트된 상태값을 기대 결과와 비교하거나, 특정 함수가 적절한 인수와 함께 호출되었는지 검증

## 12-2. E2E 테스트

E2E (end-to-end) 테스트

- 여러 컴포넌트와 서비스에 걸쳐 발생하는 실세계의 사용자 상호작용을 시뮬레이션해 애플리케이션의 완전한 기능을 평가
- 프론트엔드, 백엔드를 포함한 모든 시스템이 사용자의 관점에서 제대로 작동함을 보장

### 실습: Playwright로 /counter 페이지 테스트

- 참고: src/tests/e2e/counter-page.spec.ts

1. 루트 라우트에서 시작하는 Playwright 테스트 파일 생성
2. 루트 라우트에서 사용자가 링크를 클릭했을 때 /counter 라우트로 이동하는지 확인

- 카운터 링크를 찾고 클릭하면
- url이 /counter 로 바뀌는지 검증

3. /counter 라우트에서 count 값 증가, 감소하기

- 앱에서 가상의 api를 호출
  - 테스트 아닐 경우에는 실패하고 기본 상태를 반환
  - 테스트일 경우에는 api 응답을 mocking하여 가상의 데이터 반환되게 함

## 12-3. 통합 테스트

- 애플리케이션의 여러 단위 혹은 컴포넌트 사이의 상호작용을 테스트
- 단위 테스트와 e2e 테스트의 중간 성격

## 12-4. 스냅샷 테스트

- 특정 시점에서의 컴포넌트의 UI 출력을 캡쳐하고 이를 미래의 출력과 비교하여 의도치 않은 변경이 발생하지 않았음을 보장
- Jest와 RTL 활용

상세 과정

- 컴포넌트의 렌더링 스냅샷 만들고 직렬화하여 저장
- 새로운 스냅샷 만들고 기존 스냅샷과 비교

## 12-5. 애플리케이션을 어떻게 테스트해야 하는가?

### 언제 스냅숏 테스트를 작성해야 하는가?

- 기본 테스트보다는 보조적으로 사용
- 스냅숏을 작게 유지하여 개별 컴포넌트 테스트에 초점

### 100%의 코드 커버리지를 항상 목표로 해야 하는가?

- 코드 커버리지: 테스트로 커버된 코드 베이스의 비율
- Jest를 활용해 코드 커버리지 추적 가능

100%의 코드 커버리지가 항상 필요한 것은 아니며 오히려 비생산적일 수 있다

- 불필요한 테스트를 작성하게 되어, 시간과 리소스를 낭비할 수 있음
- 팀에서 의논하여 60% 혹은 80% 등 합리적으로 커버리지 임계값을 결정할 수 있음

### 모든 코드를 TDD 마인드셋으로 작성해야 하는가?

TDD(Test-driven development)의 장점

1. 개선된 코드 품질
2. 쉬운 디버깅과 유지보수

- 테스트가 실패했을 때, 어떤 방향으로 수정해야 할지 파악이 쉬움

3. 빠른 개발

- 구체적인 기능과 컴포넌트에 초점을 맞춰 큰 태스크를 작은 덩어리로 나누기 쉬워짐

하지만, TDD 방법론이 익숙하지 않은 상태에서 엄격하게 적용할 필요는 없다

### 단위 테스트 vs 통합 테스트 vs E2E 테스트

테스팅 피라미드 접근법

- 테스트 커버리지를 최대화하면서 테스팅에 필요한 시간과 리소스를 최소화하는 접근법
- 단위 테스트가 가장 많아야 하고, 통합 테스트, E2E 테스트 순으로 많아야 한다
  - E2E 테스트는 만들고 유지보수하는데 실행 및 제작에 더 많은 시간이 소요됨
- TypeScript를 적극적으로 활용하여 정적 타이핑으로 에러를 줄일 수 있다
