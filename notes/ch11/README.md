# ch.11 확장 가능한 웹 아키텍쳐

- 확장성(scalability): 필요할 때 리소스를 추가하거나 제거함으로써 다양한 워크로드를 처리하는 시스템의 능력

## 11-1. 확장성

- 시스템의 성장을 우아하게 다룰 수 있는 웹 아키텍쳐의 능력
- 사용자, 트랜잭션, 요청, 데이터가 늘어남에 따라 시스템에 그 성능을 유지하거나 개선할 수 있고, 지속적으로 비용 대비 효과를 거둘 수 있는 능력
- 선형적으로 확장될 수 있는 인프라 스트럭쳐를 구축하는 것을 의미
  - 리소스를 추가하면 선형적으로 추가된 리소스에 따라 성능이 개선되는 것

### 로드 밸런서(load balancer)

- 확장 가능한 웹 애플리케이션의 핵심 컴포넌트
- 유입되는 트래픽을 여러 서버에 분산시켜 부하의 균형을 맞추고, 개별 서버가 과도한 부하에 의해 오작동하는 것을 방지
- 클라이언트와 서버 클러스터 사이에 위치하여 웹사이트 혹은 애플리케이션으로 유입되는 모든 트래픽의 진입점 및 관리 역할

로드 밸런서 구성

- 알고리즘 선택: 로드 밸런싱 알고리즘(라운드 로빈, 최소 커넥션, IP 해시 등)을 구현해 로드 밸런서가 여러 서버에 트래픽을 분산하는 방법 지정
- 헬스 체크: 정기적인 헬스 체크를 수행해 서버들이 잘 작동하고 있음을 보장해야 한다. 어떤 서버가 헬스 체크에 실패하면, 헬스 체크에 성공할 때까지 해당 서버는 풀에서 제거되어야 한다
- 자동 스케일링: 자동 스케일링 시스템으로 아키텍쳐가 효율적으로 확장/축소됨을 보장해야 함

AWS, GCP, Azure 같은 클라우드 서비스를 사용하면 로드 밸런서 구현 및 기능들이 제공되어 쉽게 사용 가능

### 캐싱

- 캐싱: 빈번하게 접근되는 데이터를 항상 접근할 수 있는 스토리지 위치(cache)에 일시적으로 저장해 데이터 가져오기 속도를 높이는 프로세스
- 캐싱은 원래 데이터 저장소(서버나 DB)에 접근하는 것보다 더 빠르게 데이터를 가져오는 것을 목표로 한다

캐싱 구현 사례

- 브라우저 캐싱: 사용자가 방문했을 때 웹사이트 리소스를 사용자의 로컬 컴퓨터에 저장함으로써 방문 시 로딩 타임을 줄인다
- CDN 캐싱: 지역적으로 분산되어 있는 서버를 활용해 콘텐츠를 빠르게 전달
- 애플리케이션/데이터 캐싱: 데이터를 Redis, Memcached 같은 인메모리 캐시에 저장하여 DB와 백엔드 서버의 부하를 줄임

콘텐츠 특성마다 다른 캐싱 전략이 필요

- 이미지, CSS, JS같은 컨텐츠는 자주 변경되지 않아, 오랫동안 캐싱해도 되지만
- 유저 정보, 상품 리뷰 같은 데이터는 자주 변경되므로 다른 캐싱 전략 필요

### CDN(Content Delivery Network)

- 전세계의 여러 위치에 전략적으로 배치된 서버 네트워크
- 사용자에게 가장 가까운 서버에서 정적 콘텐츠(HTML, CSS, JS, 애셋 등)를 제공
- 지리적으로 사용자에게 가까운 위치로 콘텐츠를 가져다주기 때문에 지연을 줄이고 콘텐츠 전달 속도를 높임
- 클라우드 서비스 공급자들은 대개 통합된 CDN 서비스를 제공하므로 CDN 쉽게 배포 가능
  - AWS: Amazon CloudFront
  - Azure: Azure CDN
  - GCP: Cloud CDN

### 수평적 확장과 수직적 확장

- 정확한 사용자 수를 예측하고 확장을 위해 필요한 인프라 스트럭쳐를 결정하는 것은 매우 어렵다. 그래서 조직들은 수평적 확장과 수직적 확장을 조합

수평적 확장

- scale out 이라고도 함
- 요청이 늘어나면 새로운 서버를 풀에 추가하여 워크로드를 분산
  - 애플리케이션의 클라우드 아키텍처에 많은 장비를 추가하는 것
  - 예) 클러스터 서버 or 새 인스턴스 를 추가
- 유연성과 탄력성이 있어서 웹 기반 아키텍쳐에서 선호됨

수평적 확장이 적합한 경우

- 단일 실패 포인트로 인한 다운 타임을 피하고 싶을때
- 애플리케이션을 빈번하게 업그레이드할 때
- 벤더 락인(lock-in)을 피하고 여러 서비스를 탐색하고 싶을 때

수직적 확장

- scale up 이라고도 함
- 한 단위의 리소스를 최대화해서 증가하는 부하를 처리하는 것
  - 예) 서버를 실행하는 물리 머신에 프로세싱 파워나 메모리를 추가하거나 SW 관점에서 알고리즘이나 애플리케이션 코드를 최적화하는 것
- 새로운 서버를 설정하기 위한 복잡성이 요구되지 않아서 수평적 확장보다 쉽고 빠르다
- 단, 한 대의 서버를 물리적으로 업그레이드하는데 한계가 존재

수직적 확장이 적합한 경우

- 운용 비용을 줄인 단순한 아키텍쳐가 필요할 때
- 낮은 전력을 소비하면서 확장할 수 있는 시스템이 필요할 때
- 낮은 비용으로 쉽게 설치 및 확장할 수 있는 시스템이 필요할 때
- 애플리케이션 호환성을 유지하고 싶을 때

자동 스케일링

- 모던 클라우드 서비스들은 수평적 확장과 수직적 확장 전략을 단순화할 수 있는 해결책을 제공
- 자동 스케일링은 서버 부하에 따라 컴퓨팅 리소스의 수를 자동으로 조정하여 동적으로 수평적 확장
- 또한 크기 조정이 가능한 인스턴스를 제공하여 수직적 확장을 용이하게 함

### 마이크로서비스(MSA)

- 마이크로서비스(micro service): 애플리케이션을 작고, 독립적으로 배포할 수 있는 서비스로 분해하는 아키텍쳐 접근법
- 분해된 서비스들은 독립적으로 확장 및 관리 가능
- 각 서비스들은 고유의 프로세스를 실행하며 경량 메커니즘(HTTP 리소스 API or RPC 호출)을 사용해 서로 통신

MSA vs 모놀리식(monolithic) 아키텍쳐

- 모놀리식 아키텍쳐는 애플리케이션의 모든 컴포넌트가 강하게 통합되어 있어 확장시 동반 확장되어야 하는데, 이는 비효율적임
- MSA는 각 서비스를 독립적으로 확장할 수 있어 효율적
  - 애플리케이션의 어떤 부분에 많은 요청이 걸리면 관련된 서비스만 스케일 업하면 된다

## 11-2. scalable 애플리케이션의 특징

확장성이 좋은(= 쉽게 확장 가능한, scalable, scalability가 좋은) 애플리케이션 특징

- 가용성과 신뢰성: 부하 상황에 빠지면 안되고, 요청을 신뢰할 수 있도록 처리해야 한다
- 성능: 부하 상황에서도 낮은 지연(latency)으로 작동해야 한다
- 관리 가능성: 쉽게 아키텍쳐의 문제를 진단하고 이해할 수 있어야 하며 업데이트나 수정이 쉬워야 함
- 비용: 애플리케이션 구축, 유지, 확장 비용이 과도하면 안됨

웹 애플리케이션 아키텍쳐의 4개의 기본계층

1. 웹 서버
2. 데이터베이스 서버

- 확장하기 제일 어려움 -> master-slave 복제를 통해 DB 확장의 복잡성을 어느정도 해결
- master-slave 복제: master 노드(읽기, 쓰기 가능)와 slave 노드(읽기만 가능)로 DB를 복제하여 DB 확장
- 로드 밸런서가 master 노드에 부하를 분산하여 최적의 성능 보장

3. 로드 밸런서
4. 공유 파일 서버

베스트 프랙티스

- 데이터베이스 최적화
  - 여러 서버 사이에 데이터를 분산해서 성능과 확장을 개선
  - 인덱싱, 쿼리 최적화, 데이터베이스 샤딩(sharding), 파티셔닝
- 비동기 처리
  - 백그라운드에서 시간이 소요되는 태스크를 처리하여 병목을 예방

## 11-3. 쿠버네티스와 도커는 어디에 적합한가?

### 도커

- 오픈소스 플랫폼으로 컨테이너 안에서 애플리케이션의 생성, 배포, 실행 프로세스를 단순화
- 컨테이너: 애플리케이션과 그 의존성을 함께 패키징하며 모든 환경에서 이들이 일관성있게 실행됨을 보장

도커의 장점

1. 이식성

- 도커 컨테이너는 다양한 환경에서 일관성있게 실행될 수 있으므로 개발 환경(머신 등)의 차이에서 발생하는 문제를 해결

2. 격리

- 컨테이너는 애플리케이션과 그 의존성을 캡슐화하고 충돌을 최소화하며 보안을 개선

3. 리소스 효율

- 호스트 운영체제의 커널을 공유하고 가상 머신보다 더 적은 리소스를 소비

4. 버전 관리 및 컴포넌트 재사용

- 도커 이미지는 버전 관리와 공유가 쉬워 코드 재사용이 가능

5. 생태계와 커뮤니티

도커의 단점

1. Windows 지원이 제한적

- Windows 컨테이너는 리눅스에 비해 기능이 부실

### 쿠버네티스

- 오픈소스 컨테이너 오케스트레이션 플랫폼
- 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화
- 도커 및 다른 컨테이너화 기술들과 함께 작동되도록 설계됨

쿠버네티스의 장점

1. 확장성

- 컨테이너화된 애플리케이션 관리와 확장을 단순화해서 증가된 요청을 쉽게 처리

2. 고가용성

- 실패한 컨테이너를 자동으로 찾아내고 대체하여 높은 가동시간과 탄력성 보장

3. 로드 밸런싱과 서비스 디스커버리

- 컨테이너화한 애플리케이션들에 대한 내장 로드 밸런싱 및 서비스 디스커버리 기능 제공

4. 롤링 업데이트와 롤백

- 최소한의 다운타임으로 매끄러운 애플리케이션 업데이트와 롤백 지원

5. 생태계

- 다양한 커스텀 리소스와 서드파티 플러그인 사용 가능

쿠버네티스의 단점

1. 리소스 오버헤드

- 쿠버네티스 클러스터는 컨트롤 플레인 컴포넌트를 위한 추가 리소스를 요구하여 인프라 사용 비용 증가로 이어질 수 있음

2. Stateful 애플리케이션에 대한 지원 제한

- StatefulSets를 통해 상태를 갖는 애플리케이션에 대한 지원을 개선했지만 상태를 갖지 않는 애플리케이셔네 비해 관리가 어려움

## 11-4. Vercel과 Netlify 같은 기술은 어디에 적합한가?

- Vercel과 Netlify는 AWS와 GCP 위에 구축된 플랫폼으로 FE 웹 애플리케이션을 위한 호스팅, 배포 솔루션을 제공하며 확장성에도 좋음
- 정적 사이트와 서버리스 기능에 대한 배포 및 확장 프로세스를 단순화할 수 있음

장점

1. 단순화된 배포

- Git 저장소와 통합되어 자동으로 구현 및 배포 가능

2. 서버리스 기능

- 서버리스 기능을 통해 인프라 관리할 필요 없이 백엔드 코드 작성 가능
- 서버리스 기능은 요청 수에 따라 오토 스케일링됨

3. 글로벌 CDN

4. 오토 스케일링

5. CI/CD

6. 커스텀 도메인과 HTTPS

- 커스텀 도메인 구성과 자동 HTTP 인증 관리를 제공하여 보안 설정 프로세스를 단순화
