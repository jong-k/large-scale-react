# ch3. 모듈성

## 대규모 애플리케이션을 구축하는 핵심 원칙

대규모 애플리케이션을 구축하는 비밀은 절대로 대규모 애플리케이션을 구축하지 않는 것 - Justin Meyer

- 애플리케이션을 작은 조각으로 나누기
  - 코드의 모듈화, 컴포넌트화 -> 코드의 재사용성을 높임
- 테스트 가능한 Byte 크기의 그 조각들을 합쳐서 큰 애플리케이션 만들기
  - 독립적으로 개발 및 테스트할 수 있는 모듈로 나누기

## 3-1. 자바스크립트에서의 모듈

### JavaScript module 구문

- export 선언: 함수, 객체, 원시 값 등 모든 것을 export
- import 선언: 다른 모듈을 import

### React에서의 컴포넌트화

- 컴포넌트: UI의 구분된 조각이며 재사용 가능

### 재사용 가능한 컴포넌트를 식별하기

컴포넌트화하기 좋은 후보들

- 버튼, 메뉴, 카드 같은 반복되는 요소들
- 헤더, 컨텐츠 영역, 푸터 같은 페이지의 구역들
- 기능의 논리적 덩어리

예) Post 컴포넌트 리팩토링

- https://github.com/jong-k/large-scale-react/commit/9d4861256d8b7ece851ddc157f18a5aa5f1b874b
- PostHeader, PostContent, PostFooter 컴포넌트로 나누기
- 테스트와 유지보수가 쉬워지며 재사용도 가능하다

별도의 컴포넌트로 분리하는 것을 결정 할때 고려할 요소

- 재사용성: 특정한 UI 혹은 기능을 애플리케이션의 여러 부분에서 반복한다면 컴포넌트로 만드는 것이 좋다
- 단순성, 가독성: 작은 컴포넌트로 만들고 각각의 책임에만 집중하게 만들면 코드를 쉽게 이해할 수 있다
- 개선된 테스트 가능성: 컴포넌트가 작고 집중된 책임을 가질수록 내부의 상태와 사이드 이펙트가 적어져 테스트하기 쉽다
- 성능: 큰 컴포넌트가 리렌더링 되는 것보다, 렌더링이 필요한 부분을 작은 컴포넌트로 만들면, 불필요한 리렌더링을 줄일 수 있다

디자인 시스템

- 재사용 가능한 컴포넌트, 가이드라인, 애셋의 집합
- React 컴포넌트 설계와 개발을 표준화하는데 도움이 된다

## 3-2. 지연 로딩(Lazy Loading)

- 리소스가 필요할 때만 로딩
- 최초에 로딩되는 데이터를 줄임으로써 애플리케이션의 성능을 효과적으로 개선

React에서 제공하는 lazy 함수와 Suspense 컴포넌트를 활용

- lazy: 요청이 있을 때 컴포넌트를 로딩할 수 있게 하는 함수
- Suspense: 지연 컴포넌트가 로딩되는 동안 fallback 컴포넌트를 표시하기 위해 사용하는 컴포넌트

### 정적 import

- 파일 최상단에서 import를 선언해 컴포넌트를 로딩하는 방식
- 예

```tsx
import Post from "./components/Post";

export default function App() {
  return (
    <div>
      <Post />
    </div>
  );
}
```

- 전체 Post 컴포넌트와 그 의존성들을 가져와서 실행한 후 App 컴포넌트를 초기화
- 초기 렌더링 시 Post 컴포넌트가 당장 필요하지 않다면, 초기 렌더링 시간이 불필요하게 지연된다

### 동적 import

- 컴포넌트가 필요할 때 lazy 함수를 사용하여 로딩하는 방식
- 예

```tsx
import { lazy, Suspense } from "react";

const Post = lazy(() => import("./components/Post"));

export default function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <Post />
      </Suspense>
    </div>
  );
}
```

- 동적 import 구문을 활용해 Post 컴포넌트를 비동기 로딩 (import 결과는 promise)
- Post 컴포넌트는 실제로 필요할 때에만 로딩되므로 초기 번들 사이즈를 줄이며 App 컴포넌트 로딩 시간을 개선
- Suspense 컴포넌트를 사용해 Post 컴포넌트가 로딩되는 동안의 로딩 메시지 혹은 플레이스홀더를 표시

### 상호작용으로 지연 로딩 유발

- 상호작용(interaction)으로도 지연 로딩을 유발할 수 있다
- 예) 버튼 클릭하여 Post 컴포넌트 동적 로딩하기

```tsx
import { useState } from "react";

export default function App() {
  const [Post, setPost] = useState(null);

  const handleClick = () => {
    import("./components/Post").then(module => {
      setPost(() => module.default); // default export. named export 의 경우 default 대신 모듈 이름 넣으면 됨
    });
  };

  return <div>{Post ? <Post /> : <button onClick={handleClick}>Post 보기</button>}</div>;
}
```

lazy 함수를 사용한 동적 import는 즉시 필요하지 않은 큰 컴포넌트에만 사용해야 한다

- 코드에 복잡성이 추가되고, SSR 환경에서는 Hydration Mismatch 에러를 일으킬 수 있음
  - 서버에서 import가 불가 (SSR에서는 모든 마크업이 동기적으로 렌더링)
  - Next.js 에서는 dynamic 함수를 제공 (ssr 옵션도 false로 설정해야 함)
  - 참고 https://nextjs.org/docs/app/guides/lazy-loading

### Intersection Observer API를 사용한 지연 로딩

뷰포트에 특정 요소가 보일 때 컴포넌트를 동적으로 로딩할 수 있다

- src/pages/IntersectionObserverPage.tsx 참조

## 3-3. 코드 스플리팅

애플리케이션 코드 전체를 보다 작은, 관리 가능한 조각으로 나눠 대규모 애플리케이션의 성능을 최적화하는 기법

- 하나의 bundle.js 를 작은 덩어리로 분할하는 것
- 전체 애플리케이션을 미리 로딩하지 않고, 사용자에게 필요한 순간에 필요한 코드만 로딩하는 것을 목표로 함

코드 스플리팅 패턴

- 라우트에 따라 분할: 사용자의 탐색에 따라 페이지 모듈을 로딩
  - 현재 페이지에 관한 코드만 로딩
- 컴포넌트에 따라 분할: 그래프나 테이블 같은 큰 컴포넌트를 Lazy Loading
- on-demand Loading: 사용자가 버튼 등을 클릭할 때 코드를 로딩

코드 스플리팅을 구현하려면, 가장 먼저 애플리케이션의 critical path를 식별해야 함

- critical path: 애플리케이션이 사용자에게 표시되기 전에 반드시 로딩되어야 하는 리소스의 순서
- 어떤 리소스를 먼저 로딩해야 하는지 알아야 한다

### 코드 스플리팅 전략

엔트리 포인트 분할

- 초기 자바스크립트 파일(엔트리 포인트)을 작은 덩어리로 자른다
- 사용자가 페이지에 방문할 때, 그 페이지에 관한 코드만 로딩된다
  - root page
  - /product page
  - /contact page
- 더 빠른 로딩 시간과 더 나은 사용자 경험을 제공할 수 있다
  - 사용자가 모든 페이지를 전부 방문하지 않을 수도 있으므로 불필요한 데이터를 가져오는 것을 줄일 수 있다

벤더 분할

- 서드파티 의존성을 분리
  - 애플리케이션에서 사용하는 서드파티 의존성은 js 번들에 포함된다
  - 이로 인해 번들의 크기는 커지고 로딩 속도는 느려진다
- 벤더 분할을 사용하면 서드파티 의존성 코드를 별도의 덩어리로 잘라내 독립적으로 캐싱한다
  - 이러면, 애플리케이션의 일부분이 업데이트되어도, 의존성들은 캐싱되어 사용자들이 다시 다운로드받을 필요가 없다

동적 분할

- 페이지 단위로 분할하는 엔트리 포인트 분할과 다르게 원하는 부분을 필요할 때 로딩하게 한다

컴포넌트 수준 분할

- 각 컴포넌트를 필요할 때만 Lazy Loading
- 컴포넌트를 기본적으로 Lazy Loading하기 때문에 지연을 증가시킬 수도 있다

라우트 기반 분할

- 엔트리 포인트 분할과 비슷
- 라우트에 기반해 각각의 번들로 분할
- 네트워크 대역폭 관점에서는 컴포넌트 수준 분할보다 비효율적

### 코드 스플리팅의 트레이드 오프

기본적으로 JS 번들 파일은 1개이다. 그런데 적극적으로 코드 스플리팅을 해서 번들 파일이 수십개가 될 수도 있다.

성능 관점

- 수많은 번들 파일은 캐싱이나 중복 제거 관점에서는 좋을 수 있지만, 압축률이 적고, 로딩 성능에 악영향을 끼칠 수 있다
- 번들 파일이 25개를 넘으면 브라우저 성능 관점에서 영향이 나타난다
- 번들이 100개를 넘으면 성능에 심각한 악영향을 끼친다

상호운용성

- 브라우저, 서버, CDN마다 코드 스플리팅을 다르게 구현할 수 있으며 이는 호환성 이슈로 이어질 수 있다

오버헤드

- 코드 스플리팅은 로딩 성능은 개선하지만, 처리할 파일 갯수가 많아지며 추가적인 오버헤드로 속도 저하를 불러올 수 있다

디버깅

- 번들 파일이 여러개라 디버그가 힘들 수 있다

빌드 복잡성

- 개별적으로 빌드해야 할수도 있어서 빌드 복잡성이 증가
