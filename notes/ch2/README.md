# ch2. 소프트웨어 복잡성 관리하기

소프트웨어 엔지니어링에서 가장 중요한 스킬중 하나는 복잡성을 최소화하는 것

- 그 이유는, 복잡성은 소프트웨어 개발자들이 새로운 기능을 추가하거나, 기존 기능의 손상없이 시스템을 변경하는 것을 어렵게 하기 때문
- 복잡한 요구사항은 복잡한 코드로 이어지므로, 마냥 단순한 코드를 기대할 수 없다
- 복잡성은 한번 발생하면 자연적으로 계속해서 증가하는 경향이 있다. 제거하는 과정에서 다른 위치로 옮겨가기도 한다.
- 본질적 복잡성과 불필요한 복잡성을 구분하여 복잡성을 최소화해야 한다.

## 2-1. 복잡성 설명하기

### 내재적 복잡성(문제가 가진 복잡성)

- 개발자가 통제할 수 없는 요소를 포함
- 도메인이 복잡하다면, 도메인의 복잡성을 이해하는데 노력해야 함
- 주로 레거시 코드와 관련이 깊음

### 우발적 복잡성(해결책이 가진 복잡성)

- 문제에 관한 해결책을 구현하는 과정에서 만들어지는 복잡성을 의미
- 개발자가 통제할 수 있음
- 문제를 더 잘 이해할 수록 해결책을 찾아낼 수 있다
- 해결책이 가진 복잡성은 원래 문제가 가진 복잡성을 초과해서는 안됨

## 2-2. 복잡성의 근본 원인 파악하기

시스템의 복잡성 원인 예시

- 개발자가 고려해야 하는 것들의 양
- 시스템의 상이한 요소들 사이의 상호 의존성
- 제품과 해당 제품을 구축하기 위해 사용한 코드 간의 불일치

## 2-3. 소프트웨어 설계 철학

John Ousterhout의 A Philosophy of Software Design(소프트웨어 설계 철학) 책에서는 의존성과 모호성 2가지를 복잡성을 일으키는 주요 요인으로 본다

- 의존성(dependency): 코드의 어떤 부분을 격리한 상태에서 이해하거나 수정할 수 없을 때 발생
- 모호성(obscurity): 중요한 정보가 명확하지 않을 때 발생
  - 개발 당시 문서가 부족했거나, 설계가 너무 크고 복잡할 때

고수준 복잡성

- 팀의 개발 속도나 민첩함 감소
- 비효율성, 불안정성, 불확실성 증가
- 전반적인 개발자들의 불만이나 두려움

저수준 복잡성

- 변경 증폭: 겉으로 보기에 작은 변경을 하기 위해 여러 파일을 수정해야 한다
- 인지 부하: 하나의 태스크를 완료하기 위해 학습이 필요하고, 학습에 필요한 시간이 오래 걸려서 결과적으로 일정 지연을 초래
- 무엇을 모르는지 모르는 것: 변경되어야 할 코드 혹은 프로그래머가 태스크를 완료하기 위해 필요한 정보를 모름

## 2-4. 타르 웅덩이 밖으로

Out of the Tar Pit(타르 웅덩이 밖으로) 라는 논문에서 벤 모슬리와 피터 마크스는 시스템을 이해하기 어렵게 만드는 어떤 것을 복잡성이라고 정의

복잡성을 해소하기 위한 처방

- 함수형 프로그래밍 언어 사용: 상태의 복잡성을 길들이는데 도움
- 상태와 로직을 분리해 시스템을 이해하고 추론하기 쉽게 만들기
- 코드를 짧게 유지
- 추상화를 사용해 불필요한 세부사항 숨기기

실제 세계에서 복잡성을 다룰 때

- 가능한 우발적 복잡성을 피하기
- 시스템의 순수한 로직으로부터 복잡성을 분리하기
  - 우발적이지만 유용한 부분들이 제거되더라도 시스템이 올바르게 작동하도록 함

## 2-5. 단순함이 쉬움을 만든다

- 쉬움(easy): 주관적이며 친숙함 혹은 무언가에 접근하기 쉬운 것
- 단순함(simple): 객관적이며 상호 연결 수준이나 시스템의 복잡성과 연관

사용하기 쉬운 도구를 선택하는 것도 좋지만, 만들어지는 시스템의 전반적인 단순성에 초점을 두어야 한다

## 2-6. 은탄환은 없다

논문 No Silver Bullet 에서는 생산성, 신뢰성, 단순성을 한 단계 향상시킬 수 있는 단일 발전은 없다고 주장

- 복잡성은 시스템의 부분들 사이의 상호작용에 의해 야기됨
- 추상화, 모듈성, 계층 구조를 사용하면 개발자들이 한 시점에 시스템의 작은 부분에 집중하도록 함으로써 복잡성을 줄이는데 도움을 줄 수 있음

복잡성으로 발생하는 문제

- 팀 커뮤니케이션의 어려움
- 제품 오류, 비용 초과, 일정 지연
- 인력 이동(지식 소실)
- 열거되지 않은 많은 상태
- 확장성 결여(구조의 복잡성)
- 예기치 못한 상태(보안 구멍)
- 프로젝트 파악의 어려움

## 2-7. 시스템 디자인과 아키텍처 복잡성의 비용

소프트웨어 아키텍처 개선(리팩토링)으로 복잡성을 줄이는 것의 효과

- 생산성 증가
- 결함 발생 감소
- 개발자 이직 감소

오늘 느리게 가는 것은 내일 더 빠르게 갈 수 있음을 의미

- 개발 속도를 늦추고 품질에 집중하면
- 개발팀이 유지보수성이 높고 확장 가능한 시스템을 만들 수 있음
- 이는 궁극적으로 빠르고 효율적인 개발 사이클을 만들어냄

## 2-8. 팀은 어떻게 복잡성을 관리할 수 있는가?

대규모 시스템을 작은 모듈화된 컴포넌트로 나누는 것이 복잡성을 관리하는 효율적 방법

- 모듈성
- 잘 정의된 인터페이스
- 계층형 아키텍처
- 이를 통해 저수준 컴포넌트들로 구성된 고수준 모듈을 만들 수 있다

오픈소스 소프트웨어를 사용하는 것도 모듈화된 컴포넌트들을 여러 조직에서 개발하고 유지보수하는데 도움을 줄 수 있다

## 2-9. 최고의 해결책은 단순하지만 간단하지 않다

단순성

- 불필요한 복잡성을 줄이고 정말로 중요한 것에 집중
- 단순한 해결책은 이해하기 쉽지만, 구현하기는 어려움
- 단순성의 목표: 불필요하거나 혼동을 일으키는 모든 것을 제거

### 오컴의 면도날(Occam's Razor) 관점에서 소프트웨어 설계

- 엔티티들은 반드시 필요하지 않다면 늘려서는 안된다
  - 즉, 한 문제에 대해 여러 가능한 해결책이 있다면, 불필요한 가정 없이 가장 단순한 옵션을 택해야 한다
- 초기 단계에서 빠른 의사 결정을 내리는데 도움을 주는 멘탈 모델

#### 예) 빠르게 웹 앱을 만들어야 할때, 인증/인가 기능을 어떻게 하지?

옵션1: 직접 개발

- 많은 작업을 필요로 함
- DB 스키마, 사용자 인증/인가 및 관리에 필요한 모든 기능을 설계하고 구현해야 함

옵션2: 서드파티 라이브러리 활용

- OAuth or Firebase Authentication 같은 도구를 활용
- 보다 적은 작업을 필요로 함

오컴의 면도날 관점에서는 옵션2를 택해야 함

- 가장 작업량이 적어 합리적으로 가장 단순한 해결책
- 물론, 더 간단한 서드파티 라이브러리나 프레임워크가 있을 수도 있음

## 2-10. 때때로 필수적인 복잡성은 다른 어딘가에는 살아남아야 한다

- 필수적인 복잡성을 숨기려 시도하지 말고, 적절한 공간을 마련해야 한다
  - 우리가 해결하고자 하는 문제에 내재된 복잡성은 단순히 제거하거나 단순화할 수 없다
- 복잡한 부분을 옮겨서 처음 접하는 개발자들도 쉽게 사용할 수 있게 만들어야한다
  - 잘 정의된 위치에만 복잡성이 머물게 해야 함
  - 코드 베이스 안의 추상화, 문서, 온보딩 자료 등

## 2-11. 복잡성을 관리하는데 지속되는 어려움

오늘날 서드파티 모듈에 관한 의존성이 증가하는데 이는 이익보다 복잡성으로 인한 손해가 더 클 수 있음

## 2-12. 결론

효율적인 시스템을 위해 소프트웨어 복잡성을 관리하는 것이 중요하다

- 내재적 복잡성과 우발적 복잡성의 차이를 이해해야 한다
- 복잡성을 완전히 제거하는 것은 힘들다

불필요한 복잡성을 줄이고, 시스템을 단순화할 수 있는 방법을 찾는데 집중해야 한다

- 지속적으로 시스템을 리뷰하여 불필요한 복잡성이 자라나지 않게 해야 함
